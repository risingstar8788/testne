!function(){"use strict";const e=()=>{return e=null,new Promise((n=>{chrome.storage.sync.get(e,n)}));var e};var n;!function(e){e[e.Text=0]="Text",e[e.TextList=1]="TextList",e[e.Number=2]="Number",e[e.Boolean=3]="Boolean"}(n||(n={}));const t=[{key:"keywords",label:"Keywords to highlight",placeholder:"Enter each keyword to highlight on a new line",defaultValue:["d0mxss",""],type:n.TextList},{key:"ignored",label:"Files/domains to ignore",placeholder:"Do not log results with stack traces that match one of these values",defaultValue:[""],type:n.TextList},{key:"ignoredIfFirst",label:"Source files/domains to ignore",placeholder:"Ignore only if it is the source of the sink (last function in stack trace)",defaultValue:[""],type:n.TextList},{key:"maxCodeLength",label:"Truncate long code (number of characters)",placeholder:"0 = disabled",defaultValue:1024,type:n.Number},{key:"traceLimit",label:"Trace limit (ignore if sink passes by more than x functions)",placeholder:"0 = disabled",defaultValue:1024,type:n.Number},{key:"onlyLogHighlighted",label:"Only log highlighted results",placeholder:"Completely ignore results that don't contain any keywords",defaultValue:!1,type:n.Boolean},{key:"highlightKeywordMatches",label:"Highlight keyword matches",placeholder:"Might be slow if there's a large number of results or keywords",defaultValue:!0,type:n.Boolean},{key:"highlightCodeSearchResults",label:"Highlight code search results",placeholder:"Might be slow if there's a large number of results",defaultValue:!1,type:n.Boolean},{key:"groupMessagesInConsole",label:"Group messages in console",placeholder:"Put messages in console from the same page under a group",defaultValue:!1,type:n.Boolean}];let s={recordingEnabled:!0};for(const e of t)s[e.key]=e.defaultValue;const o=chrome.runtime.getURL("settings.json");var r=new XMLHttpRequest;r.open("GET",o,!1),r.send(null);const i=r.responseText||JSON.stringify(s),a=`\n{\n    // send message to the devtools panel\n    const sendMessage = (type, value) => {\n        window.postMessage({\n            untrustedTypes: true,\n            type,\n            value\n        }, '*');\n    };\n\n    let settings = ${i};\n\n    window.addEventListener('message', (event) => {\n        const message = event.data;\n        if (!message.untrustedTypes) return;\n        if (message.type === 'settingsChanged') {\n            settings = message.value;\n        }\n    });\n    sendMessage('getSettings');\n\n    let index = 0;\n    let _open = open;\n    open = function () {\n        log(arguments[0], 0, 'Window open');\n        return _open.apply(window, arguments);\n    };\n    const scopeId = Math.random().toString(36).substr(2, 2);\n    function log(input, type, sink) {\n        // ignore new events if recording has been disabled\n        if(!settings.recordingEnabled) return input;\n\n        // normalize input\n        let inputLog = input;\n        inputLog ??= '';\n        inputLog = String(inputLog);\n\n        const openGroup = () => {\n            if (index === 0 && settings.groupMessagesInConsole) {\n                if (top === self) {\n                    console.groupCollapsed('[#' + scopeId + '-*] Untrusted Types: ' + location.href);\n                }\n            }\n        };\n\n        const stackId = scopeId + '-' + index + '-' + Math.random().toString(36).substr(2, 5);\n        const errorStack = new Error().stack;\n\n        let highlightedInput = inputLog;\n        let important = false;\n        const extraArgs = [];\n        for (const keyword of settings.keywords) {\n            if (keyword.length > 1 && inputLog.includes(keyword)) {\n                highlightedInput = highlightedInput.replaceAll(keyword, '%c$&%c');\n                important = true;\n                for (let i = 0; i < inputLog.split(keyword).length - 1; i++) {\n                    extraArgs.push('color: red; border: 1px dotted red; background: yellow;');\n                    extraArgs.push('color: unset; border: reset; background: unset;');\n                }\n            }\n        }\n\n        if (important) {\n            const args = [\n                '#' + stackId + ' ' + location.href + '\\n%c' + sink + '\\n%c' + highlightedInput,\n                'background: red; color: white; font-size: 16px',\n                'background: unset; color: unset; font-size: unset;',\n                ...extraArgs\n            ];\n\n            openGroup();\n            sendMessage('sinkFound', { href: location.href, sink, input: inputLog, stack: errorStack, stackId });\n            index++;\n            console.trace(...args);\n\n        } else if (!settings.onlyLogHighlighted) {\n            const stackTraceSplit = errorStack.split('\\n');\n\n            if (settings.traceLimit && stackTraceSplit.length > settings.traceLimit) return input;\n\n            let ignored = false;\n            for (const ignoredSource of settings.ignored) {\n                if (ignoredSource.length > 1 && errorStack.includes(ignoredSource)) {\n                    ignored = true;\n                    break;\n                }\n            }\n\n            const stackTraceLastLine = stackTraceSplit[stackTraceSplit.length - 1];\n            for (const ignoredSourceIfFirst of settings.ignoredIfFirst) {\n                if (ignoredSourceIfFirst.length > 1 && stackTraceLastLine.includes(ignoredSourceIfFirst)) {\n                    ignored = true;\n                    break;\n                }\n            }\n\n            if (!ignored) {\n                openGroup();\n                console.trace('#' + stackId + ' ' + location.href + '\\n%c' + sink, 'background: #222; color: #bada55; font-size: 16px', '\\n' + inputLog);\n                sendMessage('sinkFound', { href: location.href, sink, input: inputLog, stack: errorStack, stackId });\n                index++;\n            }\n        }\n        return input;\n    }\n\n    let trustedTypesEnabled;\n    if (!trustedTypes.defaultPolicy) {\n        trustedTypes.createPolicy('default', {\n            createHTML: log,\n            createScript: log,\n            createScriptURL: log\n        });\n        trustedTypesEnabled = false;\n    } else {\n        console.warn('One or more documents are using Trusted Types. Untrusted Types is disabled.');\n        trustedTypesEnabled = true;\n    }\n    if (top === self) {\n        console.groupEnd();\n        sendMessage('pageNavigation', { href: location.href, trustedTypesEnabled });\n    }\n}\n//@ sourceURL=UNTRUSTED_TYPES_CHECK_STACK_BELOW\n`;let l=JSON.parse(i);if(l.recordingEnabled){const n=()=>{e().then((e=>{l=Object.assign(Object.assign({},s),e),window.postMessage({untrustedTypes:!0,type:"settingsChanged",value:l},"*")}))};chrome.storage.onChanged.addListener(n),n(),window.addEventListener("message",(e=>{const n=e.data;n.untrustedTypes&&e.source===window&&("getSettings"!==n.type?chrome.runtime.sendMessage(n):e.source.postMessage({untrustedTypes:!0,type:"settingsChanged",value:l},e.origin))}));const t=document.createElement("meta");t.httpEquiv="Content-Security-Policy",t.content="require-trusted-types-for 'script'";const o=document.createElement("script");o.innerHTML=a;const r=document.createElement("head");r.appendChild(t),r.appendChild(o),document.documentElement.appendChild(r),r.remove()}}();
